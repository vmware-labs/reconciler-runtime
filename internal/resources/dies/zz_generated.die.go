//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2020 VMware, Inc.
SPDX-License-Identifier: Apache-2.0
*/

// Code generated by diegen. DO NOT EDIT.

package dies

import (
	"dies.dev/apis/meta/v1"
	json "encoding/json"
	fmtx "fmt"
	apis "github.com/vmware-labs/reconciler-runtime/apis"
	"github.com/vmware-labs/reconciler-runtime/internal/resources"
	corev1 "k8s.io/api/core/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
)

var TestResourceBlank = (&TestResourceDie{}).DieFeed(resources.TestResource{})

type TestResourceDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResource
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceDie) DieImmutable(immutable bool) *TestResourceDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceDie) DieFeed(r resources.TestResource) *TestResourceDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceDie) DieFeedPtr(r *resources.TestResource) *TestResourceDie {
	if r == nil {
		r = &resources.TestResource{}
	}
	return d.DieFeed(*r)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceDie) DieRelease() resources.TestResource {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceDie) DieReleasePtr() *resources.TestResource {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *TestResourceDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceDie) DieStamp(fn func(r *resources.TestResource)) *TestResourceDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceDie) DeepCopy() *TestResourceDie {
	r := *d.r.DeepCopy()
	return &TestResourceDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceDie)(nil)

func (d *TestResourceDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResource{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceDie) SpecDie(fn func(d *TestResourceSpecDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := TestResourceSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

// StatusDie stamps the resource's status field with a mutable die.
func (d *TestResourceDie) StatusDie(fn func(d *TestResourceStatusDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := TestResourceStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

func (d *TestResourceDie) Spec(v resources.TestResourceSpec) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.Spec = v
	})
}

func (d *TestResourceDie) Status(v resources.TestResourceStatus) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.Status = v
	})
}

var TestResourceSpecBlank = (&TestResourceSpecDie{}).DieFeed(resources.TestResourceSpec{})

type TestResourceSpecDie struct {
	mutable bool
	r       resources.TestResourceSpec
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceSpecDie) DieImmutable(immutable bool) *TestResourceSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceSpecDie) DieFeed(r resources.TestResourceSpec) *TestResourceSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceSpecDie) DieFeedPtr(r *resources.TestResourceSpec) *TestResourceSpecDie {
	if r == nil {
		r = &resources.TestResourceSpec{}
	}
	return d.DieFeed(*r)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceSpecDie) DieRelease() resources.TestResourceSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceSpecDie) DieReleasePtr() *resources.TestResourceSpec {
	r := d.DieRelease()
	return &r
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceSpecDie) DieStamp(fn func(r *resources.TestResourceSpec)) *TestResourceSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceSpecDie) DeepCopy() *TestResourceSpecDie {
	r := *d.r.DeepCopy()
	return &TestResourceSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceSpecDie) Fields(v map[string]string) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.Fields = v
	})
}

func (d *TestResourceSpecDie) Template(v corev1.PodTemplateSpec) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.Template = v
	})
}

func (d *TestResourceSpecDie) ErrOnMarshal(v bool) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.ErrOnMarshal = v
	})
}

func (d *TestResourceSpecDie) ErrOnUnmarshal(v bool) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.ErrOnUnmarshal = v
	})
}

var TestResourceStatusBlank = (&TestResourceStatusDie{}).DieFeed(resources.TestResourceStatus{})

type TestResourceStatusDie struct {
	mutable bool
	r       resources.TestResourceStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceStatusDie) DieImmutable(immutable bool) *TestResourceStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceStatusDie) DieFeed(r resources.TestResourceStatus) *TestResourceStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceStatusDie) DieFeedPtr(r *resources.TestResourceStatus) *TestResourceStatusDie {
	if r == nil {
		r = &resources.TestResourceStatus{}
	}
	return d.DieFeed(*r)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceStatusDie) DieRelease() resources.TestResourceStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceStatusDie) DieReleasePtr() *resources.TestResourceStatus {
	r := d.DieRelease()
	return &r
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceStatusDie) DieStamp(fn func(r *resources.TestResourceStatus)) *TestResourceStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceStatusDie) DeepCopy() *TestResourceStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceStatusDie) Status(v apis.Status) *TestResourceStatusDie {
	return d.DieStamp(func(r *resources.TestResourceStatus) {
		r.Status = v
	})
}

func (d *TestResourceStatusDie) Fields(v map[string]string) *TestResourceStatusDie {
	return d.DieStamp(func(r *resources.TestResourceStatus) {
		r.Fields = v
	})
}

var TestResourceNoStatusBlank = (&TestResourceNoStatusDie{}).DieFeed(resources.TestResourceNoStatus{})

type TestResourceNoStatusDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResourceNoStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceNoStatusDie) DieImmutable(immutable bool) *TestResourceNoStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceNoStatusDie) DieFeed(r resources.TestResourceNoStatus) *TestResourceNoStatusDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceNoStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceNoStatusDie) DieFeedPtr(r *resources.TestResourceNoStatus) *TestResourceNoStatusDie {
	if r == nil {
		r = &resources.TestResourceNoStatus{}
	}
	return d.DieFeed(*r)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceNoStatusDie) DieRelease() resources.TestResourceNoStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceNoStatusDie) DieReleasePtr() *resources.TestResourceNoStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *TestResourceNoStatusDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceNoStatusDie) DieStamp(fn func(r *resources.TestResourceNoStatus)) *TestResourceNoStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceNoStatusDie) DeepCopy() *TestResourceNoStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceNoStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceNoStatusDie)(nil)

func (d *TestResourceNoStatusDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceNoStatusDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceNoStatusDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceNoStatusDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceNoStatusBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResourceNoStatus{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceNoStatusDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

func (d *TestResourceNoStatusDie) Spec(v resources.TestResourceSpec) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		r.Spec = v
	})
}
