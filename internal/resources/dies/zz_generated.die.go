//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2020 VMware, Inc.
SPDX-License-Identifier: Apache-2.0
*/

// Code generated by diegen. DO NOT EDIT.

package dies

import (
	"dies.dev/apis/meta/v1"
	json "encoding/json"
	fmtx "fmt"
	apis "github.com/vmware-labs/reconciler-runtime/apis"
	"github.com/vmware-labs/reconciler-runtime/internal/resources"
	corev1 "k8s.io/api/core/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	jsonpath "k8s.io/client-go/util/jsonpath"
	osx "os"
	reflectx "reflect"
	yaml "sigs.k8s.io/yaml"
)

var TestResourceBlank = (&TestResourceDie{}).DieFeed(resources.TestResource{})

type TestResourceDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResource
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceDie) DieImmutable(immutable bool) *TestResourceDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceDie) DieFeed(r resources.TestResource) *TestResourceDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceDie) DieFeedPtr(r *resources.TestResource) *TestResourceDie {
	if r == nil {
		r = &resources.TestResource{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceDie) DieFeedJSON(j []byte) *TestResourceDie {
	r := resources.TestResource{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceDie) DieFeedYAML(y []byte) *TestResourceDie {
	r := resources.TestResource{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceDie) DieFeedYAMLFile(name string) *TestResourceDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceDie) DieRelease() resources.TestResource {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceDie) DieReleasePtr() *resources.TestResource {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestResourceDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceDie) DieStamp(fn func(r *resources.TestResource)) *TestResourceDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceDie) DieStampAt(jp string, fn interface{}) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceDie) DieWith(fns ...func(d *TestResourceDie)) *TestResourceDie {
	nd := TestResourceBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceDie) DeepCopy() *TestResourceDie {
	r := *d.r.DeepCopy()
	return &TestResourceDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceDie)(nil)

func (d *TestResourceDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResource{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestResourceDie) APIVersion(v string) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestResourceDie) Kind(v string) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceDie) SpecDie(fn func(d *TestResourceSpecDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := TestResourceSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

// StatusDie stamps the resource's status field with a mutable die.
func (d *TestResourceDie) StatusDie(fn func(d *TestResourceStatusDie)) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		d := TestResourceStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

func (d *TestResourceDie) Spec(v resources.TestResourceSpec) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.Spec = v
	})
}

func (d *TestResourceDie) Status(v resources.TestResourceStatus) *TestResourceDie {
	return d.DieStamp(func(r *resources.TestResource) {
		r.Status = v
	})
}

var TestResourceSpecBlank = (&TestResourceSpecDie{}).DieFeed(resources.TestResourceSpec{})

type TestResourceSpecDie struct {
	mutable bool
	r       resources.TestResourceSpec
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceSpecDie) DieImmutable(immutable bool) *TestResourceSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceSpecDie) DieFeed(r resources.TestResourceSpec) *TestResourceSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceSpecDie) DieFeedPtr(r *resources.TestResourceSpec) *TestResourceSpecDie {
	if r == nil {
		r = &resources.TestResourceSpec{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceSpecDie) DieFeedJSON(j []byte) *TestResourceSpecDie {
	r := resources.TestResourceSpec{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceSpecDie) DieFeedYAML(y []byte) *TestResourceSpecDie {
	r := resources.TestResourceSpec{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceSpecDie) DieFeedYAMLFile(name string) *TestResourceSpecDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceSpecDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceSpecDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceSpecDie) DieRelease() resources.TestResourceSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceSpecDie) DieReleasePtr() *resources.TestResourceSpec {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceSpecDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceSpecDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceSpecDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceSpecDie) DieStamp(fn func(r *resources.TestResourceSpec)) *TestResourceSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceSpecDie) DieStampAt(jp string, fn interface{}) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceSpecDie) DieWith(fns ...func(d *TestResourceSpecDie)) *TestResourceSpecDie {
	nd := TestResourceSpecBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceSpecDie) DeepCopy() *TestResourceSpecDie {
	r := *d.r.DeepCopy()
	return &TestResourceSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceSpecDie) Fields(v map[string]string) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.Fields = v
	})
}

func (d *TestResourceSpecDie) Template(v corev1.PodTemplateSpec) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.Template = v
	})
}

func (d *TestResourceSpecDie) ErrOnMarshal(v bool) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.ErrOnMarshal = v
	})
}

func (d *TestResourceSpecDie) ErrOnUnmarshal(v bool) *TestResourceSpecDie {
	return d.DieStamp(func(r *resources.TestResourceSpec) {
		r.ErrOnUnmarshal = v
	})
}

var TestResourceStatusBlank = (&TestResourceStatusDie{}).DieFeed(resources.TestResourceStatus{})

type TestResourceStatusDie struct {
	mutable bool
	r       resources.TestResourceStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceStatusDie) DieImmutable(immutable bool) *TestResourceStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceStatusDie) DieFeed(r resources.TestResourceStatus) *TestResourceStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceStatusDie) DieFeedPtr(r *resources.TestResourceStatus) *TestResourceStatusDie {
	if r == nil {
		r = &resources.TestResourceStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceStatusDie) DieFeedJSON(j []byte) *TestResourceStatusDie {
	r := resources.TestResourceStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceStatusDie) DieFeedYAML(y []byte) *TestResourceStatusDie {
	r := resources.TestResourceStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceStatusDie) DieFeedYAMLFile(name string) *TestResourceStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceStatusDie) DieRelease() resources.TestResourceStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceStatusDie) DieReleasePtr() *resources.TestResourceStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceStatusDie) DieStamp(fn func(r *resources.TestResourceStatus)) *TestResourceStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceStatusDie {
	return d.DieStamp(func(r *resources.TestResourceStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceStatusDie) DieWith(fns ...func(d *TestResourceStatusDie)) *TestResourceStatusDie {
	nd := TestResourceStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceStatusDie) DeepCopy() *TestResourceStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceStatusDie) Status(v apis.Status) *TestResourceStatusDie {
	return d.DieStamp(func(r *resources.TestResourceStatus) {
		r.Status = v
	})
}

func (d *TestResourceStatusDie) Fields(v map[string]string) *TestResourceStatusDie {
	return d.DieStamp(func(r *resources.TestResourceStatus) {
		r.Fields = v
	})
}

var TestResourceEmptyStatusBlank = (&TestResourceEmptyStatusDie{}).DieFeed(resources.TestResourceEmptyStatus{})

type TestResourceEmptyStatusDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResourceEmptyStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceEmptyStatusDie) DieImmutable(immutable bool) *TestResourceEmptyStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceEmptyStatusDie) DieFeed(r resources.TestResourceEmptyStatus) *TestResourceEmptyStatusDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceEmptyStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceEmptyStatusDie) DieFeedPtr(r *resources.TestResourceEmptyStatus) *TestResourceEmptyStatusDie {
	if r == nil {
		r = &resources.TestResourceEmptyStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceEmptyStatusDie) DieFeedJSON(j []byte) *TestResourceEmptyStatusDie {
	r := resources.TestResourceEmptyStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceEmptyStatusDie) DieFeedYAML(y []byte) *TestResourceEmptyStatusDie {
	r := resources.TestResourceEmptyStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceEmptyStatusDie) DieFeedYAMLFile(name string) *TestResourceEmptyStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceEmptyStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceEmptyStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceEmptyStatusDie) DieRelease() resources.TestResourceEmptyStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceEmptyStatusDie) DieReleasePtr() *resources.TestResourceEmptyStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestResourceEmptyStatusDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceEmptyStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceEmptyStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceEmptyStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceEmptyStatusDie) DieStamp(fn func(r *resources.TestResourceEmptyStatus)) *TestResourceEmptyStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceEmptyStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceEmptyStatusDie) DieWith(fns ...func(d *TestResourceEmptyStatusDie)) *TestResourceEmptyStatusDie {
	nd := TestResourceEmptyStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceEmptyStatusDie) DeepCopy() *TestResourceEmptyStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceEmptyStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceEmptyStatusDie)(nil)

func (d *TestResourceEmptyStatusDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceEmptyStatusDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceEmptyStatusDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceEmptyStatusDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceEmptyStatusBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResourceEmptyStatus{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestResourceEmptyStatusDie) APIVersion(v string) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestResourceEmptyStatusDie) Kind(v string) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceEmptyStatusDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceEmptyStatusDie) SpecDie(fn func(d *TestResourceSpecDie)) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		d := TestResourceSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

// StatusDie stamps the resource's status field with a mutable die.
func (d *TestResourceEmptyStatusDie) StatusDie(fn func(d *TestResourceEmptyStatusStatusDie)) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		d := TestResourceEmptyStatusStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

func (d *TestResourceEmptyStatusDie) Spec(v resources.TestResourceSpec) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		r.Spec = v
	})
}

func (d *TestResourceEmptyStatusDie) Status(v resources.TestResourceEmptyStatusStatus) *TestResourceEmptyStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatus) {
		r.Status = v
	})
}

var TestResourceEmptyStatusStatusBlank = (&TestResourceEmptyStatusStatusDie{}).DieFeed(resources.TestResourceEmptyStatusStatus{})

type TestResourceEmptyStatusStatusDie struct {
	mutable bool
	r       resources.TestResourceEmptyStatusStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceEmptyStatusStatusDie) DieImmutable(immutable bool) *TestResourceEmptyStatusStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceEmptyStatusStatusDie) DieFeed(r resources.TestResourceEmptyStatusStatus) *TestResourceEmptyStatusStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceEmptyStatusStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceEmptyStatusStatusDie) DieFeedPtr(r *resources.TestResourceEmptyStatusStatus) *TestResourceEmptyStatusStatusDie {
	if r == nil {
		r = &resources.TestResourceEmptyStatusStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieFeedJSON(j []byte) *TestResourceEmptyStatusStatusDie {
	r := resources.TestResourceEmptyStatusStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieFeedYAML(y []byte) *TestResourceEmptyStatusStatusDie {
	r := resources.TestResourceEmptyStatusStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieFeedYAMLFile(name string) *TestResourceEmptyStatusStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceEmptyStatusStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceEmptyStatusStatusDie) DieRelease() resources.TestResourceEmptyStatusStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceEmptyStatusStatusDie) DieReleasePtr() *resources.TestResourceEmptyStatusStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceEmptyStatusStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceEmptyStatusStatusDie) DieStamp(fn func(r *resources.TestResourceEmptyStatusStatus)) *TestResourceEmptyStatusStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceEmptyStatusStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceEmptyStatusStatusDie {
	return d.DieStamp(func(r *resources.TestResourceEmptyStatusStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceEmptyStatusStatusDie) DieWith(fns ...func(d *TestResourceEmptyStatusStatusDie)) *TestResourceEmptyStatusStatusDie {
	nd := TestResourceEmptyStatusStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceEmptyStatusStatusDie) DeepCopy() *TestResourceEmptyStatusStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceEmptyStatusStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

var TestResourceNoStatusBlank = (&TestResourceNoStatusDie{}).DieFeed(resources.TestResourceNoStatus{})

type TestResourceNoStatusDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResourceNoStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceNoStatusDie) DieImmutable(immutable bool) *TestResourceNoStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceNoStatusDie) DieFeed(r resources.TestResourceNoStatus) *TestResourceNoStatusDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceNoStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceNoStatusDie) DieFeedPtr(r *resources.TestResourceNoStatus) *TestResourceNoStatusDie {
	if r == nil {
		r = &resources.TestResourceNoStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceNoStatusDie) DieFeedJSON(j []byte) *TestResourceNoStatusDie {
	r := resources.TestResourceNoStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceNoStatusDie) DieFeedYAML(y []byte) *TestResourceNoStatusDie {
	r := resources.TestResourceNoStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceNoStatusDie) DieFeedYAMLFile(name string) *TestResourceNoStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceNoStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceNoStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceNoStatusDie) DieRelease() resources.TestResourceNoStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceNoStatusDie) DieReleasePtr() *resources.TestResourceNoStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestResourceNoStatusDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceNoStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceNoStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceNoStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceNoStatusDie) DieStamp(fn func(r *resources.TestResourceNoStatus)) *TestResourceNoStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceNoStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceNoStatusDie) DieWith(fns ...func(d *TestResourceNoStatusDie)) *TestResourceNoStatusDie {
	nd := TestResourceNoStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceNoStatusDie) DeepCopy() *TestResourceNoStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceNoStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceNoStatusDie)(nil)

func (d *TestResourceNoStatusDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceNoStatusDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceNoStatusDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceNoStatusDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceNoStatusBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResourceNoStatus{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestResourceNoStatusDie) APIVersion(v string) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestResourceNoStatusDie) Kind(v string) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceNoStatusDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceNoStatusDie) SpecDie(fn func(d *TestResourceSpecDie)) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		d := TestResourceSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

func (d *TestResourceNoStatusDie) Spec(v resources.TestResourceSpec) *TestResourceNoStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNoStatus) {
		r.Spec = v
	})
}

var TestResourceNilableStatusBlank = (&TestResourceNilableStatusDie{}).DieFeed(resources.TestResourceNilableStatus{})

type TestResourceNilableStatusDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResourceNilableStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceNilableStatusDie) DieImmutable(immutable bool) *TestResourceNilableStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceNilableStatusDie) DieFeed(r resources.TestResourceNilableStatus) *TestResourceNilableStatusDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceNilableStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceNilableStatusDie) DieFeedPtr(r *resources.TestResourceNilableStatus) *TestResourceNilableStatusDie {
	if r == nil {
		r = &resources.TestResourceNilableStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceNilableStatusDie) DieFeedJSON(j []byte) *TestResourceNilableStatusDie {
	r := resources.TestResourceNilableStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceNilableStatusDie) DieFeedYAML(y []byte) *TestResourceNilableStatusDie {
	r := resources.TestResourceNilableStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceNilableStatusDie) DieFeedYAMLFile(name string) *TestResourceNilableStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceNilableStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceNilableStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceNilableStatusDie) DieRelease() resources.TestResourceNilableStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceNilableStatusDie) DieReleasePtr() *resources.TestResourceNilableStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestResourceNilableStatusDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceNilableStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceNilableStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceNilableStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceNilableStatusDie) DieStamp(fn func(r *resources.TestResourceNilableStatus)) *TestResourceNilableStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceNilableStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceNilableStatusDie) DieWith(fns ...func(d *TestResourceNilableStatusDie)) *TestResourceNilableStatusDie {
	nd := TestResourceNilableStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceNilableStatusDie) DeepCopy() *TestResourceNilableStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceNilableStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceNilableStatusDie)(nil)

func (d *TestResourceNilableStatusDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceNilableStatusDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceNilableStatusDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceNilableStatusDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceNilableStatusBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResourceNilableStatus{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestResourceNilableStatusDie) APIVersion(v string) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestResourceNilableStatusDie) Kind(v string) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceNilableStatusDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceNilableStatusDie) SpecDie(fn func(d *TestResourceSpecDie)) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		d := TestResourceSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

func (d *TestResourceNilableStatusDie) Spec(v resources.TestResourceSpec) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		r.Spec = v
	})
}

func (d *TestResourceNilableStatusDie) Status(v *resources.TestResourceStatus) *TestResourceNilableStatusDie {
	return d.DieStamp(func(r *resources.TestResourceNilableStatus) {
		r.Status = v
	})
}

var TestDuckBlank = (&TestDuckDie{}).DieFeed(resources.TestDuck{})

type TestDuckDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestDuck
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestDuckDie) DieImmutable(immutable bool) *TestDuckDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestDuckDie) DieFeed(r resources.TestDuck) *TestDuckDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestDuckDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestDuckDie) DieFeedPtr(r *resources.TestDuck) *TestDuckDie {
	if r == nil {
		r = &resources.TestDuck{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestDuckDie) DieFeedJSON(j []byte) *TestDuckDie {
	r := resources.TestDuck{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestDuckDie) DieFeedYAML(y []byte) *TestDuckDie {
	r := resources.TestDuck{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestDuckDie) DieFeedYAMLFile(name string) *TestDuckDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestDuckDie) DieFeedRawExtension(raw runtime.RawExtension) *TestDuckDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestDuckDie) DieRelease() resources.TestDuck {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestDuckDie) DieReleasePtr() *resources.TestDuck {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestDuckDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestDuckDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestDuckDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestDuckDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestDuckDie) DieStamp(fn func(r *resources.TestDuck)) *TestDuckDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestDuckDie) DieStampAt(jp string, fn interface{}) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestDuckDie) DieWith(fns ...func(d *TestDuckDie)) *TestDuckDie {
	nd := TestDuckBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestDuckDie) DeepCopy() *TestDuckDie {
	r := *d.r.DeepCopy()
	return &TestDuckDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestDuckDie)(nil)

func (d *TestDuckDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestDuckDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestDuckDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestDuckDie) UnmarshalJSON(b []byte) error {
	if d == TestDuckBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestDuck{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestDuckDie) APIVersion(v string) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestDuckDie) Kind(v string) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestDuckDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestDuckDie) SpecDie(fn func(d *TestDuckSpecDie)) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		d := TestDuckSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

func (d *TestDuckDie) Spec(v resources.TestDuckSpec) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		r.Spec = v
	})
}

func (d *TestDuckDie) Status(v resources.TestResourceStatus) *TestDuckDie {
	return d.DieStamp(func(r *resources.TestDuck) {
		r.Status = v
	})
}

var TestDuckSpecBlank = (&TestDuckSpecDie{}).DieFeed(resources.TestDuckSpec{})

type TestDuckSpecDie struct {
	mutable bool
	r       resources.TestDuckSpec
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestDuckSpecDie) DieImmutable(immutable bool) *TestDuckSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestDuckSpecDie) DieFeed(r resources.TestDuckSpec) *TestDuckSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestDuckSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestDuckSpecDie) DieFeedPtr(r *resources.TestDuckSpec) *TestDuckSpecDie {
	if r == nil {
		r = &resources.TestDuckSpec{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestDuckSpecDie) DieFeedJSON(j []byte) *TestDuckSpecDie {
	r := resources.TestDuckSpec{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestDuckSpecDie) DieFeedYAML(y []byte) *TestDuckSpecDie {
	r := resources.TestDuckSpec{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestDuckSpecDie) DieFeedYAMLFile(name string) *TestDuckSpecDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestDuckSpecDie) DieFeedRawExtension(raw runtime.RawExtension) *TestDuckSpecDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestDuckSpecDie) DieRelease() resources.TestDuckSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestDuckSpecDie) DieReleasePtr() *resources.TestDuckSpec {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestDuckSpecDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestDuckSpecDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestDuckSpecDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestDuckSpecDie) DieStamp(fn func(r *resources.TestDuckSpec)) *TestDuckSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestDuckSpecDie) DieStampAt(jp string, fn interface{}) *TestDuckSpecDie {
	return d.DieStamp(func(r *resources.TestDuckSpec) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestDuckSpecDie) DieWith(fns ...func(d *TestDuckSpecDie)) *TestDuckSpecDie {
	nd := TestDuckSpecBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestDuckSpecDie) DeepCopy() *TestDuckSpecDie {
	r := *d.r.DeepCopy()
	return &TestDuckSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestDuckSpecDie) Fields(v map[string]string) *TestDuckSpecDie {
	return d.DieStamp(func(r *resources.TestDuckSpec) {
		r.Fields = v
	})
}

var TestResourceUnexportedFieldsBlank = (&TestResourceUnexportedFieldsDie{}).DieFeed(resources.TestResourceUnexportedFields{})

type TestResourceUnexportedFieldsDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       resources.TestResourceUnexportedFields
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceUnexportedFieldsDie) DieImmutable(immutable bool) *TestResourceUnexportedFieldsDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceUnexportedFieldsDie) DieFeed(r resources.TestResourceUnexportedFields) *TestResourceUnexportedFieldsDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestResourceUnexportedFieldsDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceUnexportedFieldsDie) DieFeedPtr(r *resources.TestResourceUnexportedFields) *TestResourceUnexportedFieldsDie {
	if r == nil {
		r = &resources.TestResourceUnexportedFields{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieFeedJSON(j []byte) *TestResourceUnexportedFieldsDie {
	r := resources.TestResourceUnexportedFields{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieFeedYAML(y []byte) *TestResourceUnexportedFieldsDie {
	r := resources.TestResourceUnexportedFields{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieFeedYAMLFile(name string) *TestResourceUnexportedFieldsDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceUnexportedFieldsDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceUnexportedFieldsDie) DieRelease() resources.TestResourceUnexportedFields {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceUnexportedFieldsDie) DieReleasePtr() *resources.TestResourceUnexportedFields {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieReleaseUnstructured() *unstructured.Unstructured {
	r := d.DieReleasePtr()
	u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	if err != nil {
		panic(err)
	}
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceUnexportedFieldsDie) DieStamp(fn func(r *resources.TestResourceUnexportedFields)) *TestResourceUnexportedFieldsDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceUnexportedFieldsDie) DieStampAt(jp string, fn interface{}) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceUnexportedFieldsDie) DieWith(fns ...func(d *TestResourceUnexportedFieldsDie)) *TestResourceUnexportedFieldsDie {
	nd := TestResourceUnexportedFieldsBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceUnexportedFieldsDie) DeepCopy() *TestResourceUnexportedFieldsDie {
	r := *d.r.DeepCopy()
	return &TestResourceUnexportedFieldsDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestResourceUnexportedFieldsDie)(nil)

func (d *TestResourceUnexportedFieldsDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestResourceUnexportedFieldsDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestResourceUnexportedFieldsDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestResourceUnexportedFieldsDie) UnmarshalJSON(b []byte) error {
	if d == TestResourceUnexportedFieldsBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &resources.TestResourceUnexportedFields{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *TestResourceUnexportedFieldsDie) APIVersion(v string) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *TestResourceUnexportedFieldsDie) Kind(v string) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestResourceUnexportedFieldsDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *TestResourceUnexportedFieldsDie) SpecDie(fn func(d *TestResourceUnexportedFieldsSpecDie)) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		d := TestResourceUnexportedFieldsSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

// StatusDie stamps the resource's status field with a mutable die.
func (d *TestResourceUnexportedFieldsDie) StatusDie(fn func(d *TestResourceUnexportedFieldsStatusDie)) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		d := TestResourceUnexportedFieldsStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

func (d *TestResourceUnexportedFieldsDie) Spec(v resources.TestResourceUnexportedFieldsSpec) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		r.Spec = v
	})
}

func (d *TestResourceUnexportedFieldsDie) Status(v resources.TestResourceUnexportedFieldsStatus) *TestResourceUnexportedFieldsDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFields) {
		r.Status = v
	})
}

var TestResourceUnexportedFieldsSpecBlank = (&TestResourceUnexportedFieldsSpecDie{}).DieFeed(resources.TestResourceUnexportedFieldsSpec{})

type TestResourceUnexportedFieldsSpecDie struct {
	mutable bool
	r       resources.TestResourceUnexportedFieldsSpec
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceUnexportedFieldsSpecDie) DieImmutable(immutable bool) *TestResourceUnexportedFieldsSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeed(r resources.TestResourceUnexportedFieldsSpec) *TestResourceUnexportedFieldsSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceUnexportedFieldsSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeedPtr(r *resources.TestResourceUnexportedFieldsSpec) *TestResourceUnexportedFieldsSpecDie {
	if r == nil {
		r = &resources.TestResourceUnexportedFieldsSpec{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeedJSON(j []byte) *TestResourceUnexportedFieldsSpecDie {
	r := resources.TestResourceUnexportedFieldsSpec{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeedYAML(y []byte) *TestResourceUnexportedFieldsSpecDie {
	r := resources.TestResourceUnexportedFieldsSpec{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeedYAMLFile(name string) *TestResourceUnexportedFieldsSpecDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceUnexportedFieldsSpecDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceUnexportedFieldsSpecDie) DieRelease() resources.TestResourceUnexportedFieldsSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceUnexportedFieldsSpecDie) DieReleasePtr() *resources.TestResourceUnexportedFieldsSpec {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsSpecDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceUnexportedFieldsSpecDie) DieStamp(fn func(r *resources.TestResourceUnexportedFieldsSpec)) *TestResourceUnexportedFieldsSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceUnexportedFieldsSpecDie) DieStampAt(jp string, fn interface{}) *TestResourceUnexportedFieldsSpecDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsSpec) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceUnexportedFieldsSpecDie) DieWith(fns ...func(d *TestResourceUnexportedFieldsSpecDie)) *TestResourceUnexportedFieldsSpecDie {
	nd := TestResourceUnexportedFieldsSpecBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceUnexportedFieldsSpecDie) DeepCopy() *TestResourceUnexportedFieldsSpecDie {
	r := *d.r.DeepCopy()
	return &TestResourceUnexportedFieldsSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceUnexportedFieldsSpecDie) Fields(v map[string]string) *TestResourceUnexportedFieldsSpecDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsSpec) {
		r.Fields = v
	})
}

func (d *TestResourceUnexportedFieldsSpecDie) Template(v corev1.PodTemplateSpec) *TestResourceUnexportedFieldsSpecDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsSpec) {
		r.Template = v
	})
}

func (d *TestResourceUnexportedFieldsSpecDie) ErrOnMarshal(v bool) *TestResourceUnexportedFieldsSpecDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsSpec) {
		r.ErrOnMarshal = v
	})
}

func (d *TestResourceUnexportedFieldsSpecDie) ErrOnUnmarshal(v bool) *TestResourceUnexportedFieldsSpecDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsSpec) {
		r.ErrOnUnmarshal = v
	})
}

var TestResourceUnexportedFieldsStatusBlank = (&TestResourceUnexportedFieldsStatusDie{}).DieFeed(resources.TestResourceUnexportedFieldsStatus{})

type TestResourceUnexportedFieldsStatusDie struct {
	mutable bool
	r       resources.TestResourceUnexportedFieldsStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestResourceUnexportedFieldsStatusDie) DieImmutable(immutable bool) *TestResourceUnexportedFieldsStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeed(r resources.TestResourceUnexportedFieldsStatus) *TestResourceUnexportedFieldsStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &TestResourceUnexportedFieldsStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeedPtr(r *resources.TestResourceUnexportedFieldsStatus) *TestResourceUnexportedFieldsStatusDie {
	if r == nil {
		r = &resources.TestResourceUnexportedFieldsStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedJSON returns a new die with the provided JSON. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeedJSON(j []byte) *TestResourceUnexportedFieldsStatusDie {
	r := resources.TestResourceUnexportedFieldsStatus{}
	if err := json.Unmarshal(j, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAML returns a new die with the provided YAML. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeedYAML(y []byte) *TestResourceUnexportedFieldsStatusDie {
	r := resources.TestResourceUnexportedFieldsStatus{}
	if err := yaml.Unmarshal(y, &r); err != nil {
		panic(err)
	}
	return d.DieFeed(r)
}

// DieFeedYAMLFile returns a new die loading YAML from a file path. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeedYAMLFile(name string) *TestResourceUnexportedFieldsStatusDie {
	y, err := osx.ReadFile(name)
	if err != nil {
		panic(err)
	}
	return d.DieFeedYAML(y)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *TestResourceUnexportedFieldsStatusDie {
	j, err := json.Marshal(raw)
	if err != nil {
		panic(err)
	}
	return d.DieFeedJSON(j)
}

// DieRelease returns the resource managed by the die.
func (d *TestResourceUnexportedFieldsStatusDie) DieRelease() resources.TestResourceUnexportedFieldsStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestResourceUnexportedFieldsStatusDie) DieReleasePtr() *resources.TestResourceUnexportedFieldsStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseJSON returns the resource managed by the die as JSON. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieReleaseJSON() []byte {
	r := d.DieReleasePtr()
	j, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return j
}

// DieReleaseYAML returns the resource managed by the die as YAML. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieReleaseYAML() []byte {
	r := d.DieReleasePtr()
	y, err := yaml.Marshal(r)
	if err != nil {
		panic(err)
	}
	return y
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension. Panics on error.
func (d *TestResourceUnexportedFieldsStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	j := d.DieReleaseJSON()
	raw := runtime.RawExtension{}
	if err := json.Unmarshal(j, &raw); err != nil {
		panic(err)
	}
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestResourceUnexportedFieldsStatusDie) DieStamp(fn func(r *resources.TestResourceUnexportedFieldsStatus)) *TestResourceUnexportedFieldsStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// Experimental: DieStampAt uses a JSON path (http://goessner.net/articles/JsonPath/) expression to stamp portions of the resource. The callback is invoked with each JSON path match. Panics if the callback function does not accept a single argument of the same type or a pointer to that type as found on the resource at the target location.
//
// Future iterations will improve type coercion from the resource to the callback argument.
func (d *TestResourceUnexportedFieldsStatusDie) DieStampAt(jp string, fn interface{}) *TestResourceUnexportedFieldsStatusDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsStatus) {
		if ni := reflectx.ValueOf(fn).Type().NumIn(); ni != 1 {
			panic(fmtx.Errorf("callback function must have 1 input parameters, found %d", ni))
		}
		if no := reflectx.ValueOf(fn).Type().NumOut(); no != 0 {
			panic(fmtx.Errorf("callback function must have 0 output parameters, found %d", no))
		}

		cp := jsonpath.New("")
		if err := cp.Parse(fmtx.Sprintf("{%s}", jp)); err != nil {
			panic(err)
		}
		cr, err := cp.FindResults(r)
		if err != nil {
			// errors are expected if a path is not found
			return
		}
		for _, cv := range cr[0] {
			arg0t := reflectx.ValueOf(fn).Type().In(0)

			var args []reflectx.Value
			if cv.Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv}
			} else if cv.CanAddr() && cv.Addr().Type().AssignableTo(arg0t) {
				args = []reflectx.Value{cv.Addr()}
			} else {
				panic(fmtx.Errorf("callback function must accept value of type %q, found type %q", cv.Type(), arg0t))
			}

			reflectx.ValueOf(fn).Call(args)
		}
	})
}

// DieWith returns a new die after passing the current die to the callback function. The passed die is mutable.
func (d *TestResourceUnexportedFieldsStatusDie) DieWith(fns ...func(d *TestResourceUnexportedFieldsStatusDie)) *TestResourceUnexportedFieldsStatusDie {
	nd := TestResourceUnexportedFieldsStatusBlank.DieFeed(d.DieRelease()).DieImmutable(false)
	for _, fn := range fns {
		if fn != nil {
			fn(nd)
		}
	}
	return d.DieFeed(nd.DieRelease())
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestResourceUnexportedFieldsStatusDie) DeepCopy() *TestResourceUnexportedFieldsStatusDie {
	r := *d.r.DeepCopy()
	return &TestResourceUnexportedFieldsStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *TestResourceUnexportedFieldsStatusDie) Status(v apis.Status) *TestResourceUnexportedFieldsStatusDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsStatus) {
		r.Status = v
	})
}

func (d *TestResourceUnexportedFieldsStatusDie) Fields(v map[string]string) *TestResourceUnexportedFieldsStatusDie {
	return d.DieStamp(func(r *resources.TestResourceUnexportedFieldsStatus) {
		r.Fields = v
	})
}
